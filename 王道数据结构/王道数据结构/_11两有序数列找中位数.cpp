//一个长度为L(L21)的升序序列s，处在第|L/2|个位置的数称为s的中位数。
// 例如，若序列s1=(11,13,15,17,19)，则s1的中位数是15，两个
//序列的中位数是含它们所有元素的升序序列的中位数。
// 例如，若s2 = (2, 4, 6, 8, 20)，则s1和S2的中位数是11。
// 现在有两个等长升序序列A和B
//试设计一个在时间和空间两方面都尽可能高效的算法，
// 找出两个序列A和B的中位数。要求 :
//(1)给出算法的基本设计思想。
//(2)根据设计思想，采用C、C++或Java语言描述算法，关键之处给出注释。
//(3)说明你所设计算法的时间复杂度和空间复杂度。

//#include<iostream>
//using namespace std;
//#define MaxSize 50
//class sqList {
//public:
//	int data[MaxSize];
//	int length;
//};
//
////顺序表初始化
//void InitList(sqList& L)
//{
//	cout << "导入顺序表的元素个数" << endl;
//	cin >> L.length;
//	cout << '\n' << "依次输入每个元素的值" << endl;
//	for (int i = 0; i < L.length; i++)
//	{
//		cin >> L.data[i];
//	}
//}
//
////依次显示元素的值
//void show(sqList L)
//{
//	for (int i = 0; i < L.length; i++)
//	{
//		cout << L.data[i] << "    ";
//	}
//}
//
////做题思路
////①两个依次遍历，创建一个新递增顺序表，再找出这个新顺序表的中位数，
////就是两个表的中位数，时间复杂度O(n),空间复杂度O(n)
//
//
////②两个顺序表同时遍历，分别用i，j表示，所对应的元素进行比较，
////值小的顺序表的标识符i或j++,知道找到i+j+2=一个序列的长度
////时间复杂度O(n),空间复杂度O(1)
//
//void FindMidNum(int a[], int b[], int lenth, int& mid)
//{
//	//指针i,j,和上一轮哪个指针指向后驱
//	int i = 0, j = 0, p = -1;
//	while (i + j  < lenth)
//	{
//		if (a[i] < b[j])
//		{
//			i++;
//			p = 0;
//		}
//		else {
//			j++;
//			p = 1;
//		}
//	}
//	if (p)//中位数是j所指的值
//	{
//		mid = b[j-1];
//	}
//	else {//中位数是i所指的值
//		mid = a[i-1];
//	}
//}
//
////③通过两个序列各自求中位数，然后进行各种情况的判断，
//// 最终确定两个序列的中位数。时间复杂度O(log2n)
//
//void main()
//{
//	int a[3] = { 1,2,2 };
//	int b[3] = { 2,3,3 };
//	int mid;
//	FindMidNum(a,b,3,mid);
//	cout << "职位：" << mid;
//}