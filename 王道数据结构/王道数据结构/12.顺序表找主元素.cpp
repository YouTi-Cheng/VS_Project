//已知一个整数序列A=(a1,a2.…, an-1)，其中(0≤ai<n)
// [元素都是小于n的正整数](0≤i<n)。
//若存在ap1 = ap2 = ... = apm =x且m > n / 2(0≤pk < n),
//	(1≤k≤m)，则称x为A的主元素。例如A = (0, 5, 5, 3, 5, 7.5, 5)，
//	则5为主元素; 又如A = (0, 5, 5, 3, 5, 15, 7)，则A
//	中没有主元素。假设A中的n个元素保存在一个一维数组中，
// 请设计一个尽可能高效的算法，找出A的主元素。
//	若存在主元素，则输出该元素; 否则输出 - 1。要求:
//(1)给出算法的基本设计思想。
//(2)根据设计思想，采用C、C++或Java语言描述算法，关键之处给出注释
//(3)说明你所设计算法的时间复杂度和空间复杂度。

// 

//做题思路
// 因为顺序表中只有0~n-1的正整数，创建一个长度为n的空间，依次遍历
// 顺序表，每遍历一个元素，就在新空间对应序号的值+1，遍历完毕后，
//找到重复次数最多的元素并和n/2进行比较

//int FindMainEle(sqList L)
//{
//	sqList Fre;
//	Fre.length = L.length;
//	for (int i = 0; i < Fre.length; i++)
//	{
//		Fre.data[i] = 0;
//	}
//	//开始遍历要查找的顺序表L
//	for (int j = 0; j < L.length; j++)
//	{
//		Fre.data[L.data[j]]++;
//	}
//	//找出现次数最多的正整数
//	int num = 0,a=0;
//	for (int i = 0; i < Fre.length; i++)
//	{
//		if (Fre.data[i] > num)
//		{
//			a = i;
//			num = Fre.data[i];
//		}
//	}
//	if (num > L.length / 2)
//	{
//		return a;
//	}
//	else {
//		return -1;
//	}
//}


//完美算法 进行依次遍历，遇到相同的元素权值＋1，遇到不同的元素，权值-1；
//只有留到最后的数才有可能是主元素，最后遍历一次查找这个数出现次
// 数